[{
  "model": "main_app.codeblock",
  "pk": 1,
  "fields": {
    "name": "single-link-node",
    "python": "class Node:\r\n    def __init__(self, val, next):\r\n        self.val = val\r\n        self.next = next",
    "javascript": "const Node = (val, next) => {\r\n  let node = {}\r\n  node.val = val, node.next = next;\r\n  return node;\r\n}"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 2,
  "fields": {
    "name": "list-head",
    "python": "# list_head\r\n        self.head = None",
    "javascript": "// list-head\r\n  obj.head = null;"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 3,
  "fields": {
    "name": "list-size",
    "python": "# list-size\r\n        self.size = 0",
    "javascript": "// list-size\r\n  obj.size = 0;"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 4,
  "fields": {
    "name": "list-push",
    "python": "# list_push\r\n    def push(self, val):\r\n        new_node = Node(val, self.head)\r\n        if hasattr(self, 'size'):\r\n            self.size += 1\r\n        self.head = new_node",
    "javascript": "// list-push\r\n  obj.push = node => {\r\n    node = Node(node, obj.head);\r\n    obj.head = node;\r\n    if (obj.hasOwnProperty('size')) obj.size++;\r\n  };"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 5,
  "fields": {
    "name": "list-pop",
    "python": "# list_pop\r\n    def pop(self):\r\n        if self.head:\r\n            pop = self.head\r\n            self.head = pop.next\r\n            if hasattr(self, 'size'):\r\n                self.size -= 1\r\n            return pop.val\r\n        else:\r\n            return None",
    "javascript": "// list-pop\r\n  obj.pop = _ => {\r\n    let pop = obj.head || null;\r\n    obj.head = pop ? pop.next : null;\r\n    if (obj.hasOwnProperty('size')) obj.size--;\r\n    return pop ? pop.val : undefined;\r\n  }"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 6,
  "fields": {
    "name": "list-peek",
    "python": "# list_peek\r\n    def peek(self):\r\n        if self.head:\r\n            return self.head.val\r\n        else:\r\n            return None",
    "javascript": "// list-peek\r\n  obj.peek = _ => obj.head ? obj.head.val : undefined;"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 7,
  "fields": {
    "name": "list-is-empty",
    "python": "# list_is_empty\r\n    def is_empty(self):\r\n        if hasattr(self, 'head'):\r\n            return not bool(self.head)\r\n        if hasattr(self, 'tail'):\r\n            return not bool(self.tail)\r\n        if hasattr(self, 'size'):\r\n            return not bool(self.size)",
    "javascript": "// list-isEmpty\r\n  obj.isEmpty = _ => {\r\n    if obj.hasOwnProperty('head') return !obj.head\r\n    if obj.hasOwnProperty('tail') return !obj.tail\r\n    if obj.hasOwnProperty('size') return !obj.size\r\n}"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 8,
  "fields": {
    "name": "list-tail",
    "python": "# list_tail\r\n        self.tail = None",
    "javascript": "// list-tail\r\n  obj.tail = null;"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 9,
  "fields": {
    "name": "list-enqueue",
    "python": "# list-enqueue\r\n    def enqueue(self, node):\r\n        node = Node(node, None)\r\n        if (self.tail): \r\n            self.tail.next = node\r\n        self.tail = node\r\n        if hasattr(self,'size'): \r\n            self.size += 1\r\n        if hasattr(self,'head') and not self.head:",
    "javascript": "// list-enqueue\r\n  obj.enqueue = node => {\r\n    node = Node(node, null);\r\n    if (obj.tail) obj.tail.next = node;\r\n    obj.tail = node;\r\n    if (obj.hasOwnProperty('size')) obj.size++;\r\n    if (obj.hasOwnProperty('head') && !obj"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 10,
  "fields": {
    "name": "list-dequeue",
    "python": "# list-dequeue\r\n    def dequeue(self):\r\n        dequeue = self.head\r\n        if(dequeue):\r\n            self.head = dequeue.next\r\n            if hasattr(self, 'size'): \r\n                self.size -= 1\r\n            return dequeue.val\r\n        else:\r\n            return None",
    "javascript": "// list-dequeue\r\n  obj.dequeue = _ => {\r\n    let dequeue = obj.head;\r\n    if(dequeue) { \r\n      obj.head = dequeue.next;\r\n      if(obj.hasOwnProperty('size')) obj.size--;\r\n      return dequeue.val;\r\n    }\r\n    return undefined;\r\n  }"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 11,
  "fields": {
    "name": "binary-node",
    "python": "class Node:\r\n    def __init__(self, value, left, right):\r\n        self.value = value\r\n        self.left = left\r\n        self.right = right",
    "javascript": "const Node = (value, left, right) => {\r\n  let node = {}\r\n  node.value = value; \r\n  node.left = left;\r\n  node.right = right;\r\n  return node;\r\n}"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 12,
  "fields": {
    "name": "tree-root",
    "python": "# tree_root\r\n        self.root = None",
    "javascript": "// tree-root\r\n  obj.root = null;"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 13,
  "fields": {
    "name": "binary-tree-insert",
    "python": "# binaryTree-insert\r\n    def insert(self, node_value):\r\n        new_node = Node(node_value, None, None)\r\n        if not self.root: \r\n            self.root = new_node\r\n            return\r\n        parent_node = self.root\r\n        current_node = parent_node\r\n        while current_node:\r\n            if current_node.value >= new_node.value:\r\n                current_node = current_node.left\r\n                if not current_node: \r\n                    parent_node.left = new_node\r\n            else:\r\n                current_node = current_node.right\r\n                if not current_node: \r\n                    parent_node.right = new_node\r\n            parent_node = current_node",
    "javascript": "// binaryTree-insert\r\n  obj.insert = nodeValue => {\r\n    let newNode = Node(nodeValue, null, null);\r\n    if (!obj.root) { obj.root = newNode; return; }\r\n    let parentNode = obj.root;\r\n    let currentNode = parentNode;\r\n    while (currentNode) {\r\n      if (currentNode.value >= newNode.value) {\r\n        currentNode = currentNode.left;\r\n        if (!currentNode) parentNode.left = newNode;\r\n      }\r\n      else {\r\n        currentNode = currentNode.right;\r\n        if (!currentNode) parentNode.right = newNode;\r\n      }\r\n      parentNode = currentNode;\r\n    }\r\n  };"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 14,
  "fields": {
    "name": "binary-tree-search",
    "python": "# tree-search\r\n    def search(self, search_value):\r\n        current_node = self.root\r\n        while (current_node):\r\n            if search_value == current_node.value: \r\n                return current_node\r\n            if search_value > current_node.value:\r\n                current_node = current_node.right\r\n            else:\r\n                current_node = current_node.left\r\n        return False",
    "javascript": "// tree-search\r\n  obj.search = searchValue => {\r\n    currentNode = obj.root;\r\n    while (currentNode) {\r\n      if (searchValue === currentNode.value) return currentNode;\r\n      currentNode = searchValue > currentNode.value \r\n        ? currentNode.right \r\n        : currentNode.left;\r\n    }\r\n    return false;\r\n  }"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 15,
  "fields": {
    "name": "binary-tree-traversal-preorder",
    "python": "# tree-traversal-preorder\r\n    def pre_order_traversal(self):\r\n        stack = [self.root]\r\n        traversal = []\r\n        while len(stack) > 0:\r\n            node = stack.pop()\r\n            print(node)\r\n            if node.right: \r\n                stack.append(node.right)\r\n            if node.left:\r\n                stack.append(node.left)\r\n            traversal.append(node.value)\r\n        return traversal",
    "javascript": "// tree-traversal-preorder\r\n  obj.preOrderTraversal = _ => {\r\n    let stack = [obj.root];\r\n    let traversal = []\r\n    while (stack[0]) {\r\n      let node = stack.pop();\r\n      if (node.right) stack.push(node.right);\r\n      if (node.left) stack.push(node.left);\r\n      traversal.push(node.value)\r\n    }\r\n    return traversal;\r\n  }"
  }
}, {
  "model": "main_app.codeblock",
  "pk": 16,
  "fields": {
    "name": "binary-tree-traversal-levelorder",
    "python": "# tree-traversal-levelorder\r\n    def level_order_traversal(self):\r\n        queue = [self.root,]\r\n        index = 0\r\n        while index < len(queue):\r\n            node = queue[index]\r\n            if node.left: \r\n                queue.append(node.left)\r\n            if node.right: \r\n                queue.append(node.right)\r\n            queue[index] = node.value\r\n            index += 1\r\n        return queue",
    "javascript": "// tree-traversal-levelorder\r\n  obj.levelOrderTraversal = _ => {\r\n    let queue = [];\r\n    queue[0] = obj.root;\r\n    for (let index=0; node = queue[index]; index++) {\r\n      if (node.left) queue.push(node.left)\r\n      if (node.right) queue.push(node.right)\r\n    }\r\n    return queue.map(node => node.value);\r\n  }"
  }
}]